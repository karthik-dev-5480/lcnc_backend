package com.lcncbe.service;


import com.lcncbe.model.*;
import com.lcncbe.repository.*;
import com.lcncbe.service.DatasetService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

@Service
@Transactional
public class DatasetServiceImplementation implements DatasetService {

    @Autowired private DatasetRepository datasetRepo;
    @Autowired private DatasetTableRepository tableRepo;
    @Autowired private DatasetColumnRepository columnRepo;
    @Autowired private DatasetJoinRepository joinRepo;
    @Autowired private DatasetConditionRepository conditionRepo;
    @Autowired private DatasetParameterRepository paramRepo;
    
    @Autowired private JdbcTemplate jdbcTemplate;

    // Standard CRUD Implementations (Simplified for brevity)
    public Dataset saveDataset(Dataset ds) { return datasetRepo.save(ds); }
    public void deleteDataset(Long id) { datasetRepo.deleteById(id); }
    
    public DatasetTable saveTable(DatasetTable t) { return tableRepo.save(t); }
    public void deleteTable(Long id) { tableRepo.deleteById(id); }
    
    public DatasetColumn saveColumn(DatasetColumn c) { return columnRepo.save(c); }
    public void deleteColumn(Long id) { columnRepo.deleteById(id); }
    
    public DatasetJoin saveJoin(DatasetJoin j) { return joinRepo.save(j); }
    public void deleteJoin(Long id) { joinRepo.deleteById(id); }
    
    public DatasetCondition saveCondition(DatasetCondition c) { return conditionRepo.save(c); }
    public void deleteCondition(Long id) { conditionRepo.deleteById(id); }
    
    public DatasetParameter saveParameter(DatasetParameter p) { return paramRepo.save(p); }
    public void deleteParameter(Long id) { paramRepo.deleteById(id); }

    // --- DYNAMIC QUERY ENGINE ---
  
    @Override
    public Object executeDynamicQuery(Long datasetId, String queryType, Map<String, Object> runtimeParams) {
        Dataset ds = datasetRepo.findById(datasetId).orElseThrow();
        StringBuilder sql = new StringBuilder();
        List<Object> jdbcParams = new ArrayList<>();

        switch (queryType.toUpperCase()) {
            case "SELECT":
                return handleSelect(ds, runtimeParams);
            
            case "INSERT":
                return handleInsert(ds, runtimeParams);

            case "UPDATE":
                return handleUpdate(ds, runtimeParams);

            case "DELETE":
                return handleDelete(ds, runtimeParams);

            default:
                throw new IllegalArgumentException("Unsupported query type: " + queryType);
        }
    }

    // --- 1. SELECT LOGIC ---
    private List<Map<String, Object>> handleSelect(Dataset ds, Map<String, Object> params) {
        StringBuilder sql = new StringBuilder("SELECT ");
        String cols = ds.getSelectedColumns().stream()
            .map(c -> c.getDatasetTable().getTableAlias() + "." + c.getDataColumn().getColumnName())
            .collect(Collectors.joining(", "));
        sql.append(cols.isEmpty() ? "*" : cols);
        
        sql.append(buildFromAndJoins(ds));
        sql.append(buildWhereClause(ds, params, new ArrayList<>())); // See helper below
        
        List<Object> values = extractParamValues(ds, params);
        return jdbcTemplate.queryForList(sql.toString(), values.toArray());
    }

    // --- 2. INSERT LOGIC ---
    private Map<String, Object> handleInsert(Dataset ds, Map<String, Object> params) {
        // Typically inserts only happen on the base table (t1)
        DatasetTable base = ds.getTables().get(0);
        StringBuilder sql = new StringBuilder("INSERT INTO ")
            .append(base.getDataTable().getTableName()).append(" (");
        
        String colNames = ds.getSelectedColumns().stream()
            .map(c -> c.getDataColumn().getColumnName()).collect(Collectors.joining(", "));
        
        String placeholders = ds.getSelectedColumns().stream()
            .map(c -> "?").collect(Collectors.joining(", "));

        sql.append(colNames).append(") VALUES (").append(placeholders).append(")");

        List<Object> values = ds.getSelectedColumns().stream()
            .map(c -> params.get(c.getDataColumn().getColumnName())).collect(Collectors.toList());

        int count = jdbcTemplate.update(sql.toString(), values.toArray());
        return Map.of("affected_rows", count, "status", "success");
    }

    // --- 3. UPDATE LOGIC ---
    private Map<String, Object> handleUpdate(Dataset ds, Map<String, Object> params) {
        DatasetTable base = ds.getTables().get(0);
        StringBuilder sql = new StringBuilder("UPDATE ")
            .append(base.getDataTable().getTableName()).append(" ").append(base.getTableAlias()).append(" SET ");

        // Set columns (Using DatasetColumns as the 'to-be-updated' fields)
        List<Object> values = new ArrayList<>();
        String sets = ds.getSelectedColumns().stream()
            .map(c -> {
                values.add(params.get(c.getDataColumn().getColumnName()));
                return c.getDatasetTable().getTableAlias() + "." + c.getDataColumn().getColumnName() + " = ?";
            }).collect(Collectors.joining(", "));
        
        sql.append(sets);
        sql.append(buildWhereClause(ds, params, values));

        int count = jdbcTemplate.update(sql.toString(), values.toArray());
        return Map.of("affected_rows", count);
    }

    // --- 4. DELETE LOGIC ---
    private Map<String, Object> handleDelete(Dataset ds, Map<String, Object> params) {
        DatasetTable base = ds.getTables().get(0);
        StringBuilder sql = new StringBuilder("DELETE ").append(base.getTableAlias())
            .append(" FROM ").append(base.getDataTable().getTableName()).append(" ").append(base.getTableAlias());
        
        List<Object> values = new ArrayList<>();
        sql.append(buildWhereClause(ds, params, values));

        int count = jdbcTemplate.update(sql.toString(), values.toArray());
        return Map.of("affected_rows", count);
    }

    // --- HELPERS ---
    private String buildFromAndJoins(Dataset ds) {
        DatasetTable base = ds.getTables().stream().filter(t -> t.getTableOrder() == 1).findFirst().orElseThrow();
        StringBuilder sb = new StringBuilder(" FROM ").append(base.getDataTable().getTableName()).append(" ").append(base.getTableAlias());
        for (DatasetJoin join : ds.getJoins()) {
            sb.append(" ").append(join.getJoinType()).append(" JOIN ")
              .append(join.getRightDatasetTable().getDataTable().getTableName()).append(" ")
              .append(join.getRightDatasetTable().getTableAlias())
              .append(" ON ").append(join.getLeftDatasetTable().getTableAlias()).append(".").append(join.getLeftColumn().getColumnName())
              .append(" = ").append(join.getRightDatasetTable().getTableAlias()).append(".").append(join.getRightColumn().getColumnName());
        }
        return sb.toString();
    }

    private String buildWhereClause(Dataset ds, Map<String, Object> params, List<Object> valueCollector) {
        if (ds.getConditions().isEmpty()) return "";
        StringBuilder sb = new StringBuilder(" WHERE ");
        List<String> parts = new ArrayList<>();
        for (DatasetCondition cond : ds.getConditions()) {
            String left = cond.getLeftDatasetTable().getTableAlias() + "." + cond.getLeftColumn().getColumnName();
            if ("PARAMETER".equals(cond.getRightOperandType())) {
                parts.add(left + " " + cond.getOperator() + " ?");
                valueCollector.add(params.get(cond.getRightOperandValue()));
            } else {
                parts.add(left + " " + cond.getOperator() + " " + cond.getRightOperandValue());
            }
        }
        return sb.append(String.join(" AND ", parts)).toString();
    }

    private List<Object> extractParamValues(Dataset ds, Map<String, Object> params) {
        List<Object> values = new ArrayList<>();
        for (DatasetCondition cond : ds.getConditions()) {
            if ("PARAMETER".equals(cond.getRightOperandType())) {
                values.add(params.get(cond.getRightOperandValue()));
            }
        }
        return values;
    }
}
